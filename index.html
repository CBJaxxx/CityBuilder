

The issue is that your `index.txt` code (the "No Server" version) is incomplete. It sets up the scene and defines the `updateAgents` function, but **it is missing the `animate()` loop**.

Without the `animate()` loop, the game never renders the frames, and more importantly, `updateAgents()` is never called, so the people never spawn or move.

Here is the fixed, complete file. I have taken your `index.txt` (with the Categories and No-Server setup) and appended the missing logic and the critical `animate()` function from your working `test.txt` version.

Save this as `game.html` and double-click to play.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MicroCity 3D - No Server</title>
    <style>
        :root {
            --panel-bg: rgba(20, 25, 35, 0.9);
            --accent: #4cc9f0;
            --text: #ffffff;
            --danger: #ef476f;
            --success: #06d6a0;
        }

        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #87CEEB; user-select: none; }
        
        #canvas-container { width: 100vw; height: 100vh; display: block; position: absolute; top: 0; left: 0; z-index: 1; }

        /* --- ERROR DISPLAY --- */
        #error-display {
            display: none; 
            position: absolute; top: 10px; left: 10px; z-index: 9999;
            background: rgba(255, 0, 0, 0.9); color: white; padding: 15px; border-radius: 5px;
            font-family: monospace; max-width: 400px; border: 2px solid white; pointer-events: none;
        }
        /* --------------------- */

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            z-index: 10;
        }

        header, footer { pointer-events: auto; background: var(--panel-bg); padding: 12px 20px; backdrop-filter: blur(5px); color: var(--text); }
        
        header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.1); }
        h1 { margin: 0; font-size: 1.4rem; color: var(--accent); }
        
        .header-controls { display: flex; gap: 10px; align-items: center; }
        .btn-small {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white;
            padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; transition: 0.2s;
        }
        .btn-small:hover { background: rgba(255,255,255,0.3); }
        .btn-small.active { background: var(--accent); color: #000; border-color: var(--accent); }

        .stats-bar { display: flex; gap: 20px; text-align: center; }
        .stat-box { display: flex; flex-direction: column; }
        .stat-label { font-size: 0.7rem; color: #aaa; text-transform: uppercase; }
        .stat-val { font-size: 1.1rem; font-weight: bold; }

        footer { 
            display: flex; 
            flex-direction: column; 
            border-top: 1px solid rgba(255,255,255,0.1); 
            padding-bottom: 10px;
        }

        .category-tabs {
            display: flex; justify-content: center; gap: 5px; margin-bottom: 10px;
        }

        .cat-tab {
            background: rgba(0,0,0,0.3); border: 1px solid transparent; border-radius: 15px 15px 0 0;
            padding: 8px 16px; color: #aaa; cursor: pointer; font-size: 0.85rem; font-weight: bold;
            transition: 0.2s;
        }
        .cat-tab:hover { background: rgba(255,255,255,0.1); color: white; }
        .cat-tab.active { 
            background: var(--panel-bg); border-color: rgba(255,255,255,0.2); border-bottom: none;
            color: var(--accent); margin-bottom: -1px;
        }

        #toolbar-container {
            background: rgba(0,0,0,0.2);
            padding: 10px; border-radius: 0 0 8px 8px;
            display: flex; justify-content: center; gap: 10px; overflow-x: auto;
        }

        .tool-btn {
            background: rgba(255,255,255,0.1); border: 2px solid transparent; border-radius: 8px;
            padding: 10px; color: white; cursor: pointer; display: flex; flex-direction: column; align-items: center; min-width: 70px; transition: 0.2s;
            flex-shrink: 0;
        }
        .tool-btn:hover { background: rgba(255,255,255,0.2); transform: translateY(-2px); }
        .tool-btn.active { border-color: var(--success); background: rgba(6, 214, 160, 0.2); }
        .tool-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .tool-name { font-size: 0.75rem; margin-top: 5px; font-weight: bold; }
        .tool-cost { font-size: 0.7rem; color: #ccc; }

        .toast-container { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; gap: 8px; align-items: center; pointer-events: none; }
        .toast { background: rgba(0,0,0,0.8); color: white; padding: 8px 16px; border-radius: 20px; font-size: 0.9rem; animation: fadeOut 2.5s forwards; }
        @keyframes fadeOut { 0% { opacity: 0; transform: translateY(10px); } 10% { opacity: 1; transform: translateY(0); } 80% { opacity: 1; } 100% { opacity: 0; transform: translateY(-10px); } }

        .money-popup {
            position: absolute; font-weight: bold; font-size: 1.2rem; pointer-events: none;
            animation: floatMoney 1.2s ease-out forwards; text-shadow: 0 2px 4px rgba(0,0,0,0.6);
            z-index: 20; white-space: nowrap;
        }
        .money-pos { color: var(--success); }
        .money-neg { color: var(--danger); }
        @keyframes floatMoney {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.1); }
        }

        #building-tooltip {
            position: absolute; background: rgba(0, 0, 0, 0.8); color: white;
            padding: 8px 12px; border-radius: 6px; font-size: 0.85rem;
            pointer-events: none; display: none; border: 1px solid rgba(255,255,255,0.2); z-index: 50; white-space: nowrap;
        }
        #building-tooltip .income-pos { color: var(--success); font-weight: bold; }
        #building-tooltip .income-neg { color: var(--danger); font-weight: bold; }

        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 100;
            display: flex; justify-content: center; align-items: center; pointer-events: auto; backdrop-filter: blur(5px);
        }
        .modal-content { background: #2b2d42; padding: 30px; border-radius: 12px; max-width: 500px; color: white; border: 1px solid #5c677d; }
        .btn { background: var(--success); border: none; padding: 10px 20px; font-weight: bold; border-radius: 5px; cursor: pointer; margin-top: 15px; color: #000; }
        .btn:hover { filter: brightness(1.1); }
        
        .hint { font-size: 0.8rem; color: #aaa; margin-top: 10px; line-height: 1.4; }
        .key { background: #444; padding: 2px 6px; border-radius: 4px; border: 1px solid #666; color: white; font-weight: bold; font-family: monospace; }
    </style>
    
    <!-- Using standard script tags instead of modules to avoid "blue screen" on local file opening -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <!-- ERROR BOX -->
    <div id="error-display">‚ö†Ô∏è ERROR: Check Console</div>

    <div id="canvas-container"></div>
    <div id="building-tooltip"></div>

    <div id="ui-layer">
        <header>
            <div>
                <h1>MicroCity 3D</h1>
                <div style="font-size: 0.8rem; color: #aaa;">Version 21.2 (No Server)</div>
            </div>
            
            <div class="header-controls">
                <button id="cam-toggle" class="btn-small">üì∑ Debug Cam</button>
            </div>

            <div class="stats-bar">
                <div class="stat-box">
                    <span class="stat-label">Population</span>
                    <span class="stat-val"><span id="stat-pop">0</span> / <span id="stat-cap">0</span></span>
                </div>
                <div class="stat-box">
                    <span class="stat-label">Funds</span>
                    <span class="stat-val money-val" id="stat-money">$2500</span>
                </div>
                <div class="stat-box">
                    <span class="stat-label">Income</span>
                    <span class="stat-val" id="stat-income" style="color:#ffd700">+0</span>
                </div>
            </div>
        </header>

        <div class="toast-container" id="toast-area"></div>

        <footer>
            <div class="category-tabs" id="category-tabs"></div>
            <div id="toolbar-container"></div>
        </footer>
    </div>

    <div class="modal" id="welcome-modal">
        <div class="modal-content">
            <h2 style="color:var(--accent)">City Planner (No Server)</h2>
            <ul class="hint">
                <li>üìÇ <strong>Categories:</strong> Use the tabs at the bottom to filter building types.</li>
                <li>üßµ <strong>Dynamic Lines:</strong> Road lines disappear at intersections.</li>
                <li>üì∑ <strong>Debug Cam:</strong> Toggle free look in the header.</li>
                <li>üñ±Ô∏è <strong>Controls:</strong> Scroll to rotate buildings. Q/E to rotate camera.</li>
            </ul>
            <button class="btn" onclick="document.getElementById('welcome-modal').style.display='none'">Start Building</button>
        </div>
    </div>

    <script>
        // --- GLOBAL ERROR HANDLER ---
        window.onerror = function(message, source, lineno, colno, error) {
            const errBox = document.getElementById('error-display');
            errBox.style.display = 'block';
            errBox.innerHTML = `<strong>‚ö†Ô∏è CRITICAL ERROR:</strong><br>${message}<br><br>Fix: Make sure you are connected to the internet to load the graphics engine.`;
            console.error(error);
        };

        // --- Config ---
        const GRID_SIZE = 16;
        const TILE_SIZE = 4;
        const TICK_RATE = 2000; 
        const POP_GROWTH_RATE = 1000;

        // --- Building List with Categories ---
        const CATEGORIES = {
            road: { id: 'road', name: 'Roads', icon: 'üõ£Ô∏è' },
            residential: { id: 'residential', name: 'Residential', icon: 'üè†' },
            commercial: { id: 'commercial', name: 'Commercial', icon: 'üè™' },
            industrial: { id: 'industrial', name: 'Industrial', icon: 'üè≠' },
            services: { id: 'services', name: 'Services', icon: 'üè•' },
            utility: { id: 'utility', name: 'Utility', icon: '‚ö°' }
        };

        const BUILDINGS = {
            // Road
            road: { id: 'road', category: 'road', name: 'Road', icon: 'üõ£Ô∏è', cost: 20, income: 0, popCap: 0, workersReq: 0 },
            
            // Residential
            house: { id: 'house', category: 'residential', name: 'House', icon: 'üè†', cost: 150, income: 10, popCap: 5, workersReq: 0 },
            apartment: { id: 'apartment', category: 'residential', name: 'Apt.', icon: 'üè¢', cost: 600, income: 40, popCap: 20, workersReq: 0 },
            skyscraper: { id: 'skyscraper', category: 'residential', name: 'Tower', icon: 'üèôÔ∏è', cost: 2500, income: 150, popCap: 100, workersReq: 0 },
            
            // Commercial
            shop: { id: 'shop', category: 'commercial', name: 'Shop', icon: 'üè™', cost: 300, income: 60, popCap: 0, workersReq: 5 },
            office: { id: 'office', category: 'commercial', name: 'Office', icon: 'üíº', cost: 1200, income: 300, popCap: 0, workersReq: 30 },
            stadium: { id: 'stadium', category: 'commercial', name: 'Stadium', icon: 'üèüÔ∏è', cost: 5000, income: 600, popCap: 0, workersReq: 50 },
            
            // Industrial
            factory: { id: 'factory', category: 'industrial', name: 'Factory', icon: 'üè≠', cost: 800, income: 150, popCap: 0, workersReq: 15 },
            
            // Services
            park: { id: 'park', category: 'services', name: 'Park', icon: 'üå≥', cost: 100, income: -5, popCap: 0, workersReq: 0 },
            police: { id: 'police', category: 'services', name: 'Police', icon: 'üöî', cost: 600, income: -50, popCap: 0, workersReq: 5 },
            hospital: { id: 'hospital', category: 'services', name: 'Hospital', icon: 'üè•', cost: 1500, income: -100, popCap: 0, workersReq: 10 },
            
            // Utility
            powerplant: { id: 'powerplant', category: 'utility', name: 'Power', icon: '‚ö°', cost: 1000, income: -500, popCap: 0, workersReq: 5 },
            
            // Tools
            demolish: { id: 'demolish', category: 'utility', name: 'Clear', icon: 'üèóÔ∏è', cost: 15, income: 0, popCap: 0, workersReq: 0 }
        };

        // --- State ---
        let state = {
            money: 2500,
            population: 0,
            popCap: 0,
            grid: [], 
            selectedTool: null,
            activeCategory: 'road', 
            agents: [],
            buildRot: 0
        };

        const keysPressed = {};

        // --- Three.js Globals ---
        let scene, camera, renderer, controls;
        let raycaster, pointer;
        let hoverMesh, ghostMesh;
        let gridGroup, agentsGroup;
        let clock = new THREE.Clock();
        const tooltip = document.getElementById('building-tooltip');
        let debugEl = null; 

        // --- Init ---
        function init() {
            try {
                const container = document.getElementById('canvas-container');

                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB);
                scene.fog = new THREE.Fog(0x87CEEB, 30, 120);

                // Camera
                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(40, 40, 40); 

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(renderer.domElement);

                // Controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.maxPolarAngle = Math.PI / 3; 
                controls.minPolarAngle = Math.PI / 3;
                controls.enableRotate = false; 
                controls.mouseButtons = {
                    LEFT: null,
                    MIDDLE: null,
                    RIGHT: THREE.MOUSE.PAN 
                };
                controls.target.set(0, 0, 0); 

                // Debug Camera Toggle
                document.getElementById('cam-toggle').addEventListener('click', () => {
                    controls.enableRotate = !controls.enableRotate;
                    controls.maxPolarAngle = controls.enableRotate ? Math.PI / 2.1 : Math.PI / 3;
                    controls.minPolarAngle = controls.enableRotate ? 0.1 : Math.PI / 3;
                    document.getElementById('cam-toggle').classList.toggle('active');
                    showToast(controls.enableRotate ? "Free Camera ON" : "Free Camera OFF", "#4cc9f0");
                });

                // Debug Element
                debugEl = document.createElement('div');
                debugEl.id = 'camera-debug';
                debugEl.style.position = 'absolute';
                debugEl.style.top = '10px';
                debugEl.style.left = '10px';
                debugEl.style.color = '#ffffff';
                debugEl.style.fontFamily = 'monospace';
                debugEl.style.fontSize = '14px';
                debugEl.style.fontWeight = 'bold';
                debugEl.style.padding = '5px 10px';
                debugEl.style.backgroundColor = 'rgba(0,0,0,0.7)';
                debugEl.style.borderRadius = '5px';
                debugEl.style.border = '1px solid white';
                debugEl.style.zIndex = '100';
                document.body.appendChild(debugEl);

                // Inputs
                window.addEventListener('keydown', (e) => keysPressed[e.code] = true);
                window.addEventListener('keyup', (e) => keysPressed[e.code] = false);

                window.addEventListener('wheel', (e) => {
                    if (state.selectedTool) {
                        e.preventDefault(); 
                        if (e.deltaY > 0) state.buildRot -= Math.PI / 2;
                        else state.buildRot += Math.PI / 2;
                        updateGhostVisuals();
                    }
                }, { passive: false });

                // Lights
                const ambient = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambient);

                const sun = new THREE.DirectionalLight(0xffffff, 0.8);
                sun.position.set(50, 100, 50);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 2048;
                sun.shadow.mapSize.height = 2048;
                sun.shadow.camera.near = 0.5;
                sun.shadow.camera.far = 200;
                sun.shadow.camera.left = -60; sun.shadow.camera.right = 60;
                sun.shadow.camera.top = 60; sun.shadow.camera.bottom = -60;
                scene.add(sun);

                // Ground
                const planeGeo = new THREE.PlaneGeometry(200, 200);
                const planeMat = new THREE.MeshStandardMaterial({ color: 0x4caf50 });
                const plane = new THREE.Mesh(planeGeo, planeMat);
                plane.rotation.x = -Math.PI / 2;
                plane.receiveShadow = true;
                scene.add(plane);

                const hitGeo = new THREE.PlaneGeometry(GRID_SIZE * TILE_SIZE, GRID_SIZE * TILE_SIZE);
                const hitMat = new THREE.MeshBasicMaterial({ visible: false });
                plane.userData.hitPlane = new THREE.Mesh(hitGeo, hitMat);
                plane.userData.hitPlane.rotation.x = -Math.PI/2;
                scene.add(plane.userData.hitPlane);

                // Groups
                gridGroup = new THREE.Group();
                agentsGroup = new THREE.Group();
                scene.add(gridGroup);
                scene.add(agentsGroup);

                raycaster = new THREE.Raycaster();
                pointer = new THREE.Vector2();

                const highGeo = new THREE.BoxGeometry(TILE_SIZE, 0.2, TILE_SIZE);
                const highMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 });
                hoverMesh = new THREE.Mesh(highGeo, highMat);
                scene.add(hoverMesh);

                ghostMesh = new THREE.Group();
                scene.add(ghostMesh);

                initGrid();
                createToolbar();
                updateUI();

                window.addEventListener('resize', onResize);
                renderer.domElement.addEventListener('pointermove', onMove);
                renderer.domElement.addEventListener('pointerdown', onClick);

                setInterval(economyTick, TICK_RATE);
                setInterval(populationTick, POP_GROWTH_RATE);

            } catch (err) {
                document.getElementById('error-display').style.display = 'block';
                document.getElementById('error-display').innerText = "INIT ERROR: " + err.message;
                console.error(err);
            }
        }

        function updateCameraRotation() {
            if (controls.enableRotate) return;
            const speed = 0.03;
            if (keysPressed['KeyQ']) rotateCameraManual(speed);
            if (keysPressed['KeyE']) rotateCameraManual(-speed);
        }

        function rotateCameraManual(angleDelta) {
            const x = camera.position.x;
            const z = camera.position.z;
            const cosA = Math.cos(angleDelta);
            const sinA = Math.sin(angleDelta);
            camera.position.x = x * cosA - z * sinA;
            camera.position.z = x * sinA + z * cosA;
            camera.lookAt(controls.target);
            controls.update();
        }

        function initGrid() {
            for (let x = 0; x < GRID_SIZE; x++) {
                state.grid[x] = [];
                for (let z = 0; z < GRID_SIZE; z++) {
                    state.grid[x][z] = null;
                }
            }
        }

        function getRoadNeighbors(x, z) {
            const neighbors = [];
            const directions = [
                { dx: 1, dz: 0 }, { dx: -1, dz: 0 }, { dx: 0, dz: 1 }, { dx: 0, dz: -1 }
            ];
            directions.forEach(dir => {
                const nx = x + dir.dx;
                const nz = z + dir.dz;
                if (nx >= 0 && nx < GRID_SIZE && nz >= 0 && nz < GRID_SIZE) {
                    if (state.grid[nx][nz] && state.grid[nx][nz].type === 'road') {
                        neighbors.push({ x: nx, z: nz, dir: dir });
                    }
                }
            });
            return neighbors;
        }

        function updateRoadVisuals(x, z, mesh) {
            const lineMesh = mesh.getObjectByName('roadLine');
            if (!lineMesh) return;
            const neighbors = getRoadNeighbors(x, z);
            if (neighbors.length >= 3) lineMesh.visible = false;
            else lineMesh.visible = true;
        }

        function refreshRoadArea(x, z) {
            const directions = [
                { dx: 0, dz: 0 }, { dx: 1, dz: 0 }, { dx: -1, dz: 0 }, { dx: 0, dz: 1 }, { dx: 0, dz: -1 }
            ];
            directions.forEach(dir => {
                const nx = x + dir.dx;
                const nz = z + dir.dz;
                if (nx >= 0 && nx < GRID_SIZE && nz >= 0 && nz < GRID_SIZE) {
                    const cell = state.grid[nx][nz];
                    if (cell && cell.type === 'road' && cell.mesh) {
                        updateRoadVisuals(nx, nz, cell.mesh);
                    }
                }
            });
        }

        function hasRoadConnection(x, z) {
            let roadCount = 0;
            for(let i=0; i<GRID_SIZE; i++) for(let j=0; j<GRID_SIZE; j++) 
                if(state.grid[i][j] && state.grid[i][j].type === 'road') roadCount++;
            if (roadCount === 0) return true;
            return getRoadNeighbors(x, z).length > 0;
        }

        function getFacingDirectionFromRotation(rot) {
            const q = new THREE.Quaternion();
            q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), rot);
            const forward = new THREE.Vector3(0, 0, 1);
            forward.applyQuaternion(q);
            const dx = Math.round(forward.x);
            const dz = Math.round(forward.z);
            if (dz === 1) return 0; 
            if (dx === -1) return 1; 
            if (dz === -1) return 2; 
            if (dx === 1) return 3; 
            return 0; 
        }

        function getInitialSnapRotation(x, z) {
            const neighbors = getRoadNeighbors(x, z);
            if (neighbors.length === 0) return 0;
            const road = neighbors[0]; 
            if (road.dz === 1) return 0;
            if (road.dz === -1) return Math.PI;
            if (road.dx === 1) return -Math.PI / 2;
            if (road.dx === -1) return Math.PI / 2;
            return 0;
        }

        function isDoorFacingAnyRoad(x, z, currentRot) {
            let roadCount = 0;
            for(let i=0; i<GRID_SIZE; i++) for(let j=0; j<GRID_SIZE; j++) 
                if(state.grid[i][j] && state.grid[i][j].type === 'road') roadCount++;
            if (roadCount === 0) return true; 

            const facingIdx = getFacingDirectionFromRotation(currentRot);
            if (facingIdx === 0) {
                const nz = z + 1;
                if (nz >= 0 && nz < GRID_SIZE && state.grid[x][nz] && state.grid[x][nz].type === 'road') return true;
            }
            else if (facingIdx === 1) {
                const nx = x - 1;
                if (nx >= 0 && nx < GRID_SIZE && state.grid[nx][z] && state.grid[nx][z].type === 'road') return true;
            }
            else if (facingIdx === 2) {
                const nz = z - 1;
                if (nz >= 0 && nz < GRID_SIZE && state.grid[x][nz] && state.grid[x][nz].type === 'road') return true;
            }
            else if (facingIdx === 3) {
                const nx = x + 1;
                if (nx >= 0 && nx < GRID_SIZE && state.grid[nx][z] && state.grid[nx][z].type === 'road') return true;
            }
            return false;
        }

        function createBuildingMesh(type) {
            const group = new THREE.Group();
            const matWall = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const matWindow = new THREE.MeshStandardMaterial({ color: 0x87CEEB, roughness: 0.1, metalness: 0.8 });
            const matDoor = new THREE.MeshStandardMaterial({ color: 0x5d4037 });

            if (type === 'road') {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE, 0.2, TILE_SIZE), new THREE.MeshStandardMaterial({color: 0x555555}));
                mesh.position.y = 0.1; mesh.receiveShadow = true;
                group.add(mesh);
                const line = new THREE.Mesh(new THREE.PlaneGeometry(0.3, TILE_SIZE - 0.5), new THREE.MeshBasicMaterial({color: 0xffff00}));
                line.rotation.x = -Math.PI/2; line.position.y = 0.21;
                line.name = 'roadLine';
                group.add(line);
            }
            else if (type === 'house') {
                const w = 3.2, d = 3.2, h = 2.5;
                const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), matWall);
                body.position.y = h/2; body.castShadow = true; body.receiveShadow = true;
                group.add(body);
                const door = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.5, 0.2), matDoor);
                door.position.set(0, 0.75, d/2 + 0.05);
                group.add(door);
                const win = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 0.2), matWindow);
                win.position.set(0, 1.8, d/2 + 0.05);
                group.add(win);
                const roof = new THREE.Mesh(new THREE.ConeGeometry(2.5, 1.2, 4), new THREE.MeshStandardMaterial({color: 0xb22222}));
                roof.position.y = h + 0.6; roof.rotation.y = Math.PI/4; roof.castShadow = true;
                group.add(roof);
            }
            else if (type === 'apartment') {
                const w = 3.6, d = 3.6, h = 6;
                const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: 0xf5f5f5}));
                body.position.y = h/2; body.castShadow = true;
                group.add(body);
                const door = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.2, 0.2), matDoor);
                door.position.set(0, 1.1, d/2 + 0.05);
                group.add(door);
                for(let row=0; row<3; row++) {
                    for(let col=0; col<2; col++) {
                        const wx = (col===0 ? -0.8 : 0.8);
                        const wy = 3 + (row * 1.5);
                        const win = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.2), matWindow);
                        win.position.set(wx, wy, d/2 + 0.05);
                        group.add(win);
                    }
                }
            }
            else if (type === 'skyscraper') {
                const w = 3.8, d = 3.8, h = 12;
                const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: 0xcccccc}));
                body.position.y = h/2; body.castShadow = true;
                group.add(body);
                for(let i=1; i<h; i+=2) {
                    const stripe = new THREE.Mesh(new THREE.BoxGeometry(w+0.1, 0.5, d+0.1), new THREE.MeshStandardMaterial({color: 0x111111, roughness: 0.2}));
                    stripe.position.y = i;
                    group.add(stripe);
                }
                const door = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 0.2), new THREE.MeshStandardMaterial({color: 0x333333}));
                door.position.set(0, 1.5, d/2 + 0.05);
                group.add(door);
                const spire = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.5, 3, 8), new THREE.MeshStandardMaterial({color: 0xff0000, emissive: 0x550000}));
                spire.position.y = h + 1.5;
                group.add(spire);
            }
            else if (type === 'shop') {
                const w = 3.8, d = 3.8, h = 3;
                const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: 0xffe0b2}));
                body.position.y = h/2; body.castShadow = true;
                group.add(body);
                const glass = new THREE.Mesh(new THREE.BoxGeometry(w, 2, 0.1), new THREE.MeshStandardMaterial({color: 0xadd8e6, transparent:true, opacity:0.7}));
                glass.position.set(0, 1.5, d/2 + 0.1);
                group.add(glass);
                const door = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.2, 0.1), matDoor);
                door.position.set(0, 1.1, d/2 + 0.15);
                group.add(door);
                const awning = new THREE.Mesh(new THREE.BoxGeometry(4.2, 0.2, 1), new THREE.MeshStandardMaterial({color: 0xe53935}));
                awning.position.set(0, 2.6, d/2 + 0.4);
                group.add(awning);
            }
            else if (type === 'factory') {
                const w = 3.8, d = 3.8, h = 3.5;
                const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: 0x9e9e9e}));
                body.position.y = h/2; body.castShadow = true;
                group.add(body);
                const gar = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2, 0.2), new THREE.MeshStandardMaterial({color: 0x424242}));
                gar.position.set(0, 1, d/2 + 0.1);
                group.add(gar);
                const stack = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 2, 12), new THREE.MeshStandardMaterial({color: 0x212121}));
                stack.position.set(1, h + 1, 1); stack.castShadow = true;
                group.add(stack);
            }
            else if (type === 'office') {
                const w = 3.8, d = 3.8, h = 8;
                const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: 0x90a4ae}));
                body.position.y = h/2; body.castShadow = true;
                group.add(body);
                const winMat = new THREE.MeshStandardMaterial({color: 0xffe082, emissive: 0x332200});
                for(let y=2; y<h-1; y+=1.5) {
                    for(let side=0; side<4; side++) {
                        const win = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 0.1), winMat);
                        const pos = new THREE.Vector3(0, y, d/2 + 0.05);
                        pos.applyAxisAngle(new THREE.Vector3(0,1,0), side * Math.PI/2);
                        win.position.copy(pos);
                        win.lookAt(pos.clone().multiplyScalar(2)); 
                        group.add(win);
                    }
                }
            }
            else if (type === 'stadium') {
                const base = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 0.5, 32), new THREE.MeshStandardMaterial({color: 0xffffff}));
                base.position.y = 0.25; base.receiveShadow = true;
                group.add(base);
                const bowl = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.9, 1.5, 32, 1, true), new THREE.MeshStandardMaterial({color: 0x3e2723, side: THREE.DoubleSide}));
                bowl.position.y = 1;
                group.add(bowl);
                for(let i=0; i<4; i++) {
                    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 3), new THREE.MeshStandardMaterial({color: 0x999999}));
                    const angle = (i/4) * Math.PI * 2;
                    pole.position.set(Math.cos(angle)*1.8, 2.5, Math.sin(angle)*1.8);
                    group.add(pole);
                }
                const roof = new THREE.Mesh(new THREE.ConeGeometry(2.2, 1, 32, 1, true), new THREE.MeshStandardMaterial({color: 0xe53935, side: THREE.DoubleSide, transparent: true, opacity: 0.8}));
                roof.position.y = 4;
                group.add(roof);
            }
            else if (type === 'park') {
                const base = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 0.2, 8), new THREE.MeshStandardMaterial({color: 0x388e3c}));
                base.position.y = 0.1;
                group.add(base);
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 1.5, 6), new THREE.MeshStandardMaterial({color: 0x5d4037}));
                trunk.position.y = 0.75;
                group.add(trunk);
                const leaves = new THREE.Mesh(new THREE.DodecahedronGeometry(1.2), new THREE.MeshStandardMaterial({color: 0x4caf50}));
                leaves.position.y = 2; leaves.castShadow = true;
                group.add(leaves);
            }
            else if (type === 'police') {
                const w = 3.5, d = 3.5, h = 3;
                const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: 0x263238}));
                body.position.y = h/2; body.castShadow = true;
                group.add(body);
                const door = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 0.1), new THREE.MeshStandardMaterial({color: 0x455a64}));
                door.position.set(0, 1, d/2 + 0.05);
                group.add(door);
                const shield = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1, 0.1), new THREE.MeshStandardMaterial({color: 0xd4af37}));
                shield.position.set(0, 1.8, d/2 + 0.05);
                group.add(shield);
                const bar = new THREE.Mesh(new THREE.BoxGeometry(2, 0.3, 0.8), new THREE.MeshStandardMaterial({color: 0x111111}));
                bar.position.set(0, h + 0.15, 0);
                group.add(bar);
                const redLight = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.3, 0.8), new THREE.MeshStandardMaterial({color: 0xff0000, emissive: 0x550000}));
                redLight.position.set(-0.5, h + 0.15, 0);
                group.add(redLight);
                const blueLight = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.3, 0.8), new THREE.MeshStandardMaterial({color: 0x0000ff, emissive: 0x000055}));
                blueLight.position.set(0.5, h + 0.15, 0);
                group.add(blueLight);
            }
            else if (type === 'hospital') {
                const w = 3.8, d = 3.8, h = 5;
                const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: 0xffffff}));
                body.position.y = h/2; body.castShadow = true;
                group.add(body);
                const hBar = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.4, 0.2), new THREE.MeshStandardMaterial({color: 0xff0000, emissive: 0x550000}));
                hBar.position.set(0, h/2 + 0.5, d/2 + 0.1);
                group.add(hBar);
                const vBar = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.5, 0.2), new THREE.MeshStandardMaterial({color: 0xff0000, emissive: 0x550000}));
                vBar.position.set(0, h/2 + 0.5, d/2 + 0.1);
                group.add(vBar);
                const pad = new THREE.Mesh(new THREE.CircleGeometry(1.2, 32), new THREE.MeshBasicMaterial({color: 0x81d4fa}));
                pad.rotation.x = -Math.PI/2;
                pad.position.y = 0.25;
                group.add(pad);
            }
            else if (type === 'powerplant') {
                const base = new THREE.Mesh(new THREE.BoxGeometry(3.5, 1, 3.5), new THREE.MeshStandardMaterial({color: 0x78909c}));
                base.position.y = 0.5; base.castShadow = true;
                group.add(base);
                const tower = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.2, 4, 16), new THREE.MeshStandardMaterial({color: 0xb0bec5}));
                tower.position.set(0, 3, 0); tower.castShadow = true;
                group.add(tower);
                const steam = new THREE.Mesh(new THREE.ConeGeometry(0.8, 2, 16), new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity: 0.5}));
                steam.position.set(0, 6, 0);
                steam.name = "anim_steam";
                group.add(steam);
            }

            return group;
        }

        // --- Agents ---
        function updateAgents() {
            const targetCount = Math.floor(state.population / 4);
            if (state.agents.length < targetCount) spawnAgentOnRoad();
            else if (state.agents.length > targetCount) {
                const a = state.agents.pop();
                agentsGroup.remove(a);
            }

            state.agents.forEach(agent => {
                agent.userData.t += 0.005;
                if (agent.userData.t >= 1) {
                    const currentGx = agent.userData.gx;
                    const currentGz = agent.userData.gz;
                    const neighbors = getRoadNeighbors(currentGx, currentGz);
                    if (neighbors.length > 0) {
                        const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                        agent.userData.gx = next.x; agent.userData.gz = next.z;
                        agent.userData.start = agent.position.clone();
                        const wx = (next.x * TILE_SIZE) - ((GRID_SIZE * TILE_SIZE)/2);
                        const wz = (next.z * TILE_SIZE) - ((GRID_SIZE * TILE_SIZE)/2);
                        agent.userData.target = new THREE.Vector3(wx, 0, wz);
                        agent.userData.t = 0;
                        agent.lookAt(agent.userData.target);
                    } else {
                        agent.userData.t = 0.9; 
                    }
                } else {
                    agent.position.lerpVectors(agent.userData.start, agent.userData.target, agent.userData.t);
                }
                agent.children[1].position.y = 0.9 + Math.sin(Date.now() * 0.015) * 0.1;
            });
        }

        function spawnAgentOnRoad() {
            let attempts = 0;
            let placed = false;
            while(!placed && attempts < 50) {
                const gx = Math.floor(Math.random() * GRID_SIZE);
                const gz = Math.floor(Math.random() * GRID_SIZE);
                if (state.grid[gx][gz] && state.grid[gx][gz].type === 'road') {
                    const wx = (gx * TILE_SIZE) - ((GRID_SIZE * TILE_SIZE)/2);
                    const wz = (gz * TILE_SIZE) - ((GRID_SIZE * TILE_SIZE)/2);
                    const group = new THREE.Group();
                    const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.15, 0.5, 4, 8), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                    body.position.y = 0.4;
                    const head = new THREE.Mesh(new THREE.SphereGeometry(0.12), new THREE.MeshLambertMaterial({ color: 0xffccaa }));
                    head.position.y = 0.85;
                    group.add(body); group.add(head);
                    group.position.set(wx, 0, wz);
                    group.userData = { gx, gz, start: group.position.clone(), target: group.position.clone(), t: 1 };
                    agentsGroup.add(group);
                    state.agents.push(group);
                    placed = true;
                }
                attempts++;
            }
        }

        function spawnMoneyPopup(position3D, amount) {
            const vec = position3D.clone();
            vec.y += 5; 
            vec.project(camera);
            const x = (vec.x * .5 + .5) * window.innerWidth;
            const y = (-(vec.y * .5) + .5) * window.innerHeight;
            const el = document.createElement('div');
            el.className = 'money-popup ' + (amount >= 0 ? 'money-pos' : 'money-neg');
            el.innerText = (amount > 0 ? '+$' : '-$') + Math.abs(amount);
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            document.body.appendChild(el);
            setTimeout(() => { el.remove(); }, 1200);
        }

        function getGridPos(point) {
            const offset = (GRID_SIZE * TILE_SIZE) / 2 - (TILE_SIZE / 2);
            const x = Math.round((point.x + offset) / TILE_SIZE);
            const z = Math.round((point.z + offset) / TILE_SIZE);
            return { x, z };
        }

        function updateGhostVisuals() {
            if (!state.selectedTool || !hoverMesh.visible) return;
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObject(scene.children.find(c=>c.userData.hitPlane));

            if (intersects.length > 0) {
                const pos = getGridPos(intersects[0].point);
                const autoRot = getInitialSnapRotation(pos.x, pos.z);
                ghostMesh.rotation.y = autoRot + state.buildRot;

                const tool = BUILDINGS[state.selectedTool];
                const valid = !state.grid[pos.x][pos.z] && 
                              state.money >= tool.cost && 
                              canBuild(tool) && 
                              (tool.id === 'road' || isDoorFacingAnyRoad(pos.x, pos.z, ghostMesh.rotation.y));
                
                ghostMesh.children[0].traverse(c => {
                    if(c.isMesh) c.material.color.setHex(valid ? 0xffffff : 0xff0000);
                });
            }
        }

        function onMove(e) {
            pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            
            const buildingIntersects = raycaster.intersectObjects(gridGroup.children, true);
            tooltip.style.display = 'none';
            if (buildingIntersects.length > 0) {
                let target = buildingIntersects[0].object;
                while(target.parent && target.parent !== gridGroup) target = target.parent;
                const pos = getGridPos(target.position);
                const data = state.grid[pos.x][pos.z];
                if (data && data.def.income !== 0) {
                    tooltip.style.display = 'block';
                    tooltip.innerHTML = `<div>${data.def.name}</div><div>Income: <span class="${data.def.income > 0 ? 'income-pos' : 'income-neg'}">$${data.def.income}/tick</span></div>`;
                    tooltip.style.left = (e.clientX + 15) + 'px';
                    tooltip.style.top = (e.clientY + 15) + 'px';
                }
            }

            const intersects = raycaster.intersectObject(scene.children.find(c=>c.userData.hitPlane));
            if (intersects.length > 0) {
                const pos = getGridPos(intersects[0].point);
                if (pos.x >= 0 && pos.x < GRID_SIZE && pos.z >= 0 && pos.z < GRID_SIZE) {
                    const wx = (pos.x * TILE_SIZE) - ((GRID_SIZE * TILE_SIZE)/2) + (TILE_SIZE/2);
                    const wz = (pos.z * TILE_SIZE) - ((GRID_SIZE * TILE_SIZE)/2) + (TILE_SIZE/2);
                    hoverMesh.position.set(wx, 0.1, wz);
                    hoverMesh.visible = true;

                    const tool = BUILDINGS[state.selectedTool];
                    if (tool && state.selectedTool !== 'demolish') {
                        ghostMesh.visible = true;
                        ghostMesh.position.set(wx, 0, wz);
                        const autoRot = getInitialSnapRotation(pos.x, pos.z);
                        ghostMesh.rotation.y = autoRot + state.buildRot;

                        if (ghostMesh.userData.type !== state.selectedTool) {
                            while(ghostMesh.children.length) ghostMesh.remove(ghostMesh.children[0]);
                            const m = createBuildingMesh(state.selectedTool);
                            m.traverse(c => { if(c.isMesh) { 
                                c.material = c.material.clone(); 
                                c.material.transparent = true; c.material.opacity = 0.5; 
                            }});
                            ghostMesh.add(m);
                            ghostMesh.userData.type = state.selectedTool;
                        }

                        const valid = !state.grid[pos.x][pos.z] && 
                                      state.money >= tool.cost && 
                                      canBuild(tool) && 
                                      (tool.id === 'road' || isDoorFacingAnyRoad(pos.x, pos.z, ghostMesh.rotation.y));
                        
                        ghostMesh.children[0].traverse(c => {
                            if(c.isMesh) c.material.color.setHex(valid ? 0xffffff : 0xff0000);
                        });
                    } else {
                        ghostMesh.visible = false;
                        hoverMesh.material.color.setHex(state.selectedTool === 'demolish' && state.grid[pos.x][pos.z] ? 0xff0000 : 0xffffff);
                    }
                } else {
                    hoverMesh.visible = false; ghostMesh.visible = false;
                }
            } else {
                hoverMesh.visible = false; ghostMesh.visible = false;
            }
        }

        function onClick(e) {
            if (e.button !== 0) return;
            if (e.target.closest('.tool-btn') || e.target.closest('.modal') || e.target.closest('.cat-tab')) return;
            if (!state.selectedTool) return;

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObject(scene.children.find(c=>c.userData.hitPlane));
            
            if (intersects.length > 0) {
                const pos = getGridPos(intersects[0].point);
                if (pos.x >= 0 && pos.x < GRID_SIZE && pos.z >= 0 && pos.z < GRID_SIZE) {
                    interactTile(pos.x, pos.z);
                }
            }
        }

        function canBuild(def) {
            if (def.workersReq > 0 && state.population < def.workersReq) return false;
            return true;
        }

        function interactTile(x, z) {
            const existing = state.grid[x][z];
            const tool = BUILDINGS[state.selectedTool];

            if (state.selectedTool === 'demolish') {
                if (existing) {
                    if (state.money >= tool.cost) {
                        state.money -= tool.cost;
                        gridGroup.remove(existing.mesh);
                        state.grid[x][z] = null;
                        refreshRoadArea(x, z);
                        recalcCap();
                        updateUI();
                        showToast("Cleared", '#ef476f');
                    } else showToast("Need money!", '#ef476f');
                }
            } else {
                if (existing) { showToast("Occupied!", '#ef476f'); return; }
                if (state.money < tool.cost) { showToast("Need money!", '#ef476f'); return; }
                if (!canBuild(tool)) { showToast(`Need ${tool.workersReq} Pop!`, '#ef476f'); return; }
                
                if (tool.id !== 'road' && !hasRoadConnection(x, z)) {
                    showToast("Must connect to road!", '#ef476f');
                    return;
                }

                const initialRot = getInitialSnapRotation(x, z);
                const finalRot = initialRot + state.buildRot;
                if (tool.id !== 'road' && !isDoorFacingAnyRoad(x, z, finalRot)) {
                    showToast("Door must face road!", '#ef476f');
                    return;
                }

                state.money -= tool.cost;
                const mesh = createBuildingMesh(tool.id);
                const wx = (x * TILE_SIZE) - ((GRID_SIZE * TILE_SIZE)/2) + (TILE_SIZE/2);
                const wz = (z * TILE_SIZE) - ((GRID_SIZE * TILE_SIZE)/2) + (TILE_SIZE/2);
                mesh.position.set(wx, 0, wz);
                mesh.rotation.y = finalRot;
                gridGroup.add(mesh);
                
                mesh.scale.set(0,0,0);
                let s=0;
                const pop = () => { s+=0.1; if(s>1)s=1; mesh.scale.set(s,s,s); if(s<1)requestAnimationFrame(pop); };
                pop();

                state.grid[x][z] = { type: tool.id, mesh: mesh, def: tool };
                refreshRoadArea(x, z);
                recalcCap();
                updateUI();
                showToast(`Built ${tool.name}`, '#06d6a0');
            }
        }

        function recalcCap() {
            let cap = 0;
            state.grid.forEach(row => row.forEach(t => { 
                if(t && (t.type === 'house' || t.type === 'apartment' || t.type === 'skyscraper')) {
                    cap += t.def.popCap; 
                }
            }));
            state.popCap = cap;
        }

        function economyTick() {
            let income = 0;
            state.grid.forEach(row => row.forEach(t => { 
                if(t) {
                    income += t.def.income;
                    if (t.def.income !== 0) {
                        spawnMoneyPopup(t.mesh.position, t.def.income);
                    }
                }
            }));
            state.money += income;
            updateUI();
        }

        function populationTick() {
            if (state.population < state.popCap) state.population++;
            else if (state.population > state.popCap) state.population--;
            updateUI();
        }

        // --- UI Logic ---
        function updateUI() {
            document.getElementById('stat-money').innerText = '$' + state.money;
            document.getElementById('stat-pop').innerText = state.population;
            document.getElementById('stat-cap').innerText = state.popCap;
            
            let inc = 0;
            state.grid.forEach(row => row.forEach(t => { if(t) inc += t.def.income; }));
            const incEl = document.getElementById('stat-income');
            incEl.innerText = (inc>=0?'+':'') + inc + '/2s';
            incEl.style.color = inc >= 0 ? '#ffd700' : '#ef476f';
        }

        function showToast(msg, color) {
            const c = document.getElementById('toast-area');
            const el = document.createElement('div');
            el.className = 'toast';
            el.innerText = msg;
            if(color) el.style.borderLeft = `4px solid ${color}`;
            c.appendChild(el);
            setTimeout(() => { if(c.contains(el)) c.removeChild(el); }, 2600);
        }

        function createToolbar() {
            const tabsContainer = document.getElementById('category-tabs');
            const toolsContainer = document.getElementById('toolbar-container');
            
            tabsContainer.innerHTML = '';
            toolsContainer.innerHTML = '';

            // Create Tabs
            Object.keys(CATEGORIES).forEach(catId => {
                const cat = CATEGORIES[catId];
                const btn = document.createElement('div');
                btn.className = `cat-tab ${state.activeCategory === catId ? 'active' : ''}`;
                btn.innerText = `${cat.icon} ${cat.name}`;
                btn.onclick = () => {
                    state.activeCategory = catId;
                    state.selectedTool = null; // Deselect tool on tab switch
                    createToolbar(); // Re-render
                };
                tabsContainer.appendChild(btn);
            });

            // Create Tools for Active Category
            Object.keys(BUILDINGS).forEach(k => {
                const b = BUILDINGS[k];
                if (b.category !== state.activeCategory) return;

                const btn = document.createElement('button');
                btn.className = 'tool-btn';
                btn.innerHTML = `<span style="font-size:1.4rem">${b.icon}</span><span class="tool-name">${b.name}</span><span class="tool-cost">$${b.cost}</span>`;
                btn.onclick = () => {
                    document.querySelectorAll('.tool-btn').forEach(x => x.classList.remove('active'));
                    if (state.selectedTool === k) {
                        state.selectedTool = null;
                        controls.enableZoom = true;
                    } else { 
                        state.selectedTool = k; 
                        btn.classList.add('active'); 
                        state.buildRot = 0;
                        if(k !== 'demolish') controls.enableZoom = false;
                        else controls.enableZoom = true;
                    }
                };
                toolsContainer.appendChild(btn);
            });
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Render Loop (The Fix) ---
        function animate() {
            requestAnimationFrame(animate);
            
            // Logic Updates
            controls.update();
            updateCameraRotation();
            
            // CRITICAL: This is what updates the agents/people
            updateAgents(); 
            
            renderer.render(scene, camera);
        }

        // Start
        init();
        animate();

    </script>
</body>
</html>
```